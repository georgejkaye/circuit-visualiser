// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Circuits$CircuitVisualiser from "./Circuits.bs.js";

var andGate_000 = "âˆ§";

function andGate_003(v, c) {
  if (typeof c === "number" || c.tag !== /* Tensor */3) {
    return Pervasives.failwith("Bad input");
  } else {
    var match = c[0];
    if (match) {
      var match$1 = match[0];
      if (typeof match$1 === "number" || match$1.tag) {
        return Pervasives.failwith("Bad input");
      } else {
        var match$2 = match[1];
        if (match$2) {
          var match$3 = match$2[0];
          if (typeof match$3 === "number" || match$3.tag || match$2[1]) {
            return Pervasives.failwith("Bad input");
          } else {
            return /* Value */Block.__(0, [Curry._2(v[/* andOp */2], match$1[0], match$3[0])]);
          }
        } else {
          return Pervasives.failwith("Bad input");
        }
      }
    } else {
      return Pervasives.failwith("Bad input");
    }
  }
}

var andGate = /* Function */Block.__(4, [
    andGate_000,
    2,
    1,
    andGate_003
  ]);

var xorGate_000 = "xor";

function xorGate_003(v, c) {
  if (typeof c === "number" || c.tag !== /* Tensor */3) {
    return Pervasives.failwith("Bad input");
  } else {
    var match = c[0];
    if (match) {
      var match$1 = match[0];
      if (typeof match$1 === "number" || match$1.tag) {
        return Pervasives.failwith("Bad input");
      } else {
        var match$2 = match[1];
        if (match$2) {
          var match$3 = match$2[0];
          if (typeof match$3 === "number" || match$3.tag || match$2[1]) {
            return Pervasives.failwith("Bad input");
          } else {
            var b = match$3[0];
            var a = match$1[0];
            return /* Value */Block.__(0, [Curry._2(v[/* andOp */2], Curry._1(v[/* notOp */4], Curry._2(v[/* andOp */2], a, b)), Curry._2(v[/* orOp */3], a, b))]);
          }
        } else {
          return Pervasives.failwith("Bad input");
        }
      }
    } else {
      return Pervasives.failwith("Bad input");
    }
  }
}

var xorGate = /* Function */Block.__(4, [
    xorGate_000,
    2,
    1,
    xorGate_003
  ]);

function halfAdder(a, b) {
  return Circuits$CircuitVisualiser.composemany(/* :: */[
              /* Tensor */Block.__(3, [/* :: */[
                    a,
                    /* :: */[
                      b,
                      /* [] */0
                    ]
                  ]]),
              /* :: */[
                Circuits$CircuitVisualiser.dfork(2),
                /* :: */[
                  /* Tensor */Block.__(3, [/* :: */[
                        andGate,
                        /* :: */[
                          xorGate,
                          /* [] */0
                        ]
                      ]]),
                  /* [] */0
                ]
              ]
            ]);
}

export {
  andGate ,
  xorGate ,
  halfAdder ,
  
}
/* No side effect */
