// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function inputs(_c) {
  while(true) {
    var c = _c;
    if (typeof c === "number") {
      return 1;
    } else {
      switch (c.tag | 0) {
        case /* Identity */1 :
            return c[0];
        case /* Composition */2 :
            _c = c[0];
            continue ;
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + inputs(comp) | 0;
                        }), 0, c[0]);
        case /* Function */4 :
            return c[1];
        case /* Trace */5 :
        case /* Iter */6 :
            return inputs(c[1]) - c[0] | 0;
        case /* Value */0 :
        case /* Input */7 :
            return 0;
        case /* Output */8 :
            return 1;
        case /* Link */9 :
            _c = c[2];
            continue ;
        
      }
    }
  };
}

function outputs(_c) {
  while(true) {
    var c = _c;
    if (typeof c === "number") {
      return 1;
    } else {
      switch (c.tag | 0) {
        case /* Identity */1 :
            return c[0];
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + outputs(comp) | 0;
                        }), 0, c[0]);
        case /* Function */4 :
            return c[2];
        case /* Trace */5 :
            return outputs(c[1]) - c[0] | 0;
        case /* Composition */2 :
        case /* Iter */6 :
            _c = c[1];
            continue ;
        case /* Output */8 :
            return 0;
        case /* Link */9 :
            _c = c[2];
            continue ;
        default:
          return 1;
      }
    }
  };
}

function printComponent(v, c) {
  if (typeof c === "number") {
    return "ẟ";
  } else {
    switch (c.tag | 0) {
      case /* Value */0 :
          return Curry._1(v[/* print */5], c[0]);
      case /* Identity */1 :
          return String(c[0]);
      case /* Composition */2 :
          return printComponent(v, c[0]) + (" ⋅ " + printComponent(v, c[1]));
      case /* Tensor */3 :
          var match = c[0];
          if (match) {
            return "[" + (List.fold_left((function (string, comp) {
                            return string + (" ⊗ " + printComponent(v, comp));
                          }), printComponent(v, match[0]), match[1]) + "]");
          } else {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Circuits.re",
                    53,
                    35
                  ]
                ];
          }
      case /* Function */4 :
          return c[0];
      case /* Trace */5 :
          return "Tr[" + (String(c[0]) + ("](" + (printComponent(v, c[1]) + ")")));
      case /* Iter */6 :
          return "iter[" + (String(c[0]) + ("](" + (printComponent(v, c[1]) + ")")));
      case /* Input */7 :
          return ":" + String(c[0]);
      case /* Output */8 :
          return String(c[0]) + ":";
      case /* Link */9 :
          return "|" + (String(c[0]) + ("-" + (String(c[1]) + ("|" + printComponent(v, c[2])))));
      
    }
  }
}

function printCircuit(param) {
  return printComponent(param[/* v */0], param[/* c */1]);
}

function composemany(xs) {
  if (xs) {
    var xs$1 = xs[1];
    var x = xs[0];
    if (xs$1) {
      return /* Composition */Block.__(2, [
                x,
                composemany(xs$1)
              ]);
    } else {
      return x;
    }
  } else {
    return Pervasives.failwith("no args");
  }
}

function split$prime(_n, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var n = _n;
    if (ys) {
      var yss = ys[1];
      var y = ys[0];
      var match = n === 0;
      if (match) {
        return /* tuple */[
                xs,
                /* :: */[
                  y,
                  yss
                ]
              ];
      } else {
        _ys = yss;
        _xs = List.concat(/* :: */[
              xs,
              /* :: */[
                /* :: */[
                  y,
                  /* [] */0
                ],
                /* [] */0
              ]
            ]);
        _n = n - 1 | 0;
        continue ;
      }
    } else {
      return /* tuple */[
              xs,
              /* [] */0
            ];
    }
  };
}

function split(n, xs) {
  return split$prime(n, /* [] */0, xs);
}

var fork_000 = "⋏";

function fork_003(v, c) {
  return /* Tensor */Block.__(3, [/* :: */[
              c,
              /* :: */[
                c,
                /* [] */0
              ]
            ]]);
}

var fork = /* Function */Block.__(4, [
    fork_000,
    1,
    2,
    fork_003
  ]);

function swap(x, y) {
  return /* Function */Block.__(4, [
            "×" + ("[" + (String(x) + ("," + (String(y) + "]")))),
            x + y | 0,
            x + y | 0,
            (function (v, comp) {
                if (typeof comp === "number") {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Circuits.re",
                          95,
                          45
                        ]
                      ];
                } else if (comp.tag === /* Tensor */3) {
                  var match = split$prime(x, /* [] */0, comp[0]);
                  return /* Tensor */Block.__(3, [List.concat(/* :: */[
                                  match[1],
                                  /* :: */[
                                    match[0],
                                    /* [] */0
                                  ]
                                ])]);
                } else {
                  throw [
                        Caml_builtin_exceptions.match_failure,
                        /* tuple */[
                          "Circuits.re",
                          95,
                          45
                        ]
                      ];
                }
              })
          ]);
}

function dfork(n) {
  if (n !== 0) {
    if (n !== 1) {
      return composemany(/* :: */[
                  /* Tensor */Block.__(3, [/* :: */[
                        dfork(n - 1 | 0),
                        /* :: */[
                          fork,
                          /* [] */0
                        ]
                      ]]),
                  /* :: */[
                    /* Tensor */Block.__(3, [/* :: */[
                          /* Identity */Block.__(1, [1]),
                          /* :: */[
                            swap(n - 1 | 0, 1),
                            /* :: */[
                              /* Identity */Block.__(1, [1]),
                              /* [] */0
                            ]
                          ]
                        ]]),
                    /* [] */0
                  ]
                ]);
    } else {
      return fork;
    }
  } else {
    return /* Identity */Block.__(1, [0]);
  }
}

export {
  inputs ,
  outputs ,
  printComponent ,
  printCircuit ,
  composemany ,
  split$prime ,
  split ,
  fork ,
  swap ,
  dfork ,
  
}
/* No side effect */
