// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function printLattice(lattice) {
  switch (lattice) {
    case /* Bottom */0 :
        return "\xe2\x8a\xa5";
    case /* False */1 :
        return "f";
    case /* True */2 :
        return "t";
    case /* Top */3 :
        return "T";
    
  }
}

function inputs(_item) {
  while(true) {
    var item = _item;
    if (typeof item === "number") {
      return 1;
    } else {
      switch (item.tag | 0) {
        case /* Identity */1 :
            return item[0];
        case /* Composition */2 :
            _item = item[0];
            continue ;
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + inputs(comp) | 0;
                        }), 0, item[0]);
        case /* Gate */4 :
            return item[1];
        case /* Trace */5 :
        case /* Iter */6 :
            return inputs(item[1]) - item[0] | 0;
        case /* Value */0 :
        case /* Input */7 :
            return 0;
        case /* Output */8 :
            return 1;
        case /* Link */9 :
            _item = item[2];
            continue ;
        
      }
    }
  };
}

function outputs(_item) {
  while(true) {
    var item = _item;
    if (typeof item === "number") {
      return 1;
    } else {
      switch (item.tag | 0) {
        case /* Identity */1 :
            return item[0];
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + outputs(comp) | 0;
                        }), 0, item[0]);
        case /* Gate */4 :
            return item[2];
        case /* Trace */5 :
            return outputs(item[1]) - item[0] | 0;
        case /* Composition */2 :
        case /* Iter */6 :
            _item = item[1];
            continue ;
        case /* Output */8 :
            return 0;
        case /* Link */9 :
            _item = item[2];
            continue ;
        default:
          return 1;
      }
    }
  };
}

function compose(f, g) {
  if (outputs(f) !== inputs(g)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Circuits.re",
            58,
            4
          ]
        ];
  }
  return /* Composition */Block.__(2, [
            f,
            g
          ]);
}

function composemany(list) {
  if (list) {
    return List.fold_left(compose, list[0], list[1]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Circuits.re",
            62,
            32
          ]
        ];
  }
}

function trace(x, comp) {
  if (!(inputs(comp) >= x && outputs(comp) >= x)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Circuits.re",
            74,
            4
          ]
        ];
  }
  return /* Trace */Block.__(5, [
            x,
            comp
          ]);
}

function printCircuit$prime(component) {
  if (typeof component === "number") {
    return "ẟ";
  } else {
    switch (component.tag | 0) {
      case /* Value */0 :
          return printLattice(component[0]);
      case /* Identity */1 :
          return String(component[0]);
      case /* Composition */2 :
          return printCircuit$prime(component[0]) + (" ⋅ " + printCircuit$prime(component[1]));
      case /* Tensor */3 :
          var match = component[0];
          if (match) {
            return "[" + (List.fold_left((function (string, comp) {
                            return string + (" ⊗ " + printCircuit$prime(comp));
                          }), printCircuit$prime(match[0]), match[1]) + "]");
          } else {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Circuits.re",
                    78,
                    39
                  ]
                ];
          }
      case /* Gate */4 :
          return component[0];
      case /* Trace */5 :
          return "Tr[" + (String(component[0]) + ("](" + (printCircuit$prime(component[1]) + ")")));
      case /* Iter */6 :
          return "iter[" + (String(component[0]) + ("](" + (printCircuit$prime(component[1]) + ")")));
      case /* Input */7 :
          return ":" + String(component[0]);
      case /* Output */8 :
          return String(component[0]) + ":";
      case /* Link */9 :
          return "|" + (String(component[0]) + ("-" + (String(component[1]) + ("|" + printCircuit$prime(component[2])))));
      
    }
  }
}

function printCircuit(circuit) {
  var comp = circuit[2];
  console.log(circuit[3] + (" : " + (String(inputs(comp)) + (" → " + (String(outputs(comp)) + ("\n" + printCircuit$prime(comp)))))));
  return /* () */0;
}

var fork = /* Gate */Block.__(4, [
    "⋏",
    1,
    2
  ]);

var join = /* Gate */Block.__(4, [
    "⋎",
    1,
    2
  ]);

var stub = /* Gate */Block.__(4, [
    "~",
    1,
    0
  ]);

var delay = /* Delay */0;

exports.printLattice = printLattice;
exports.inputs = inputs;
exports.outputs = outputs;
exports.compose = compose;
exports.composemany = composemany;
exports.trace = trace;
exports.printCircuit$prime = printCircuit$prime;
exports.printCircuit = printCircuit;
exports.fork = fork;
exports.join = join;
exports.stub = stub;
exports.delay = delay;
/* No side effect */
