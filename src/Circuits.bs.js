// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Helpers$CircuitVisualiser from "./Helpers.bs.js";

function inputs$prime(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case /* Identity */1 :
          return c[0];
      case /* Composition */2 :
          _c = c[0];
          continue ;
      case /* Tensor */3 :
          return List.fold_left((function (no, comp) {
                        return no + inputs$prime(comp) | 0;
                      }), 0, c[0]);
      case /* Function */4 :
          return c[1];
      case /* Trace */6 :
      case /* Iter */7 :
          return inputs$prime(c[1]) - c[0] | 0;
      case /* Value */0 :
      case /* Input */8 :
          return 0;
      case /* Delay */5 :
      case /* Output */9 :
          return 1;
      case /* Link */10 :
          _c = c[2];
          continue ;
      
    }
  };
}

function inputs(param) {
  return inputs$prime(param[/* c */1]);
}

function outputs$prime(_c) {
  while(true) {
    var c = _c;
    switch (c.tag | 0) {
      case /* Identity */1 :
          return c[0];
      case /* Tensor */3 :
          return List.fold_left((function (no, comp) {
                        return no + outputs$prime(comp) | 0;
                      }), 0, c[0]);
      case /* Function */4 :
          return c[2];
      case /* Trace */6 :
          return outputs$prime(c[1]) - c[0] | 0;
      case /* Composition */2 :
      case /* Iter */7 :
          _c = c[1];
          continue ;
      case /* Output */9 :
          return 0;
      case /* Link */10 :
          _c = c[2];
          continue ;
      default:
        return 1;
    }
  };
}

function outputs(param) {
  return outputs$prime(param[/* c */1]);
}

function printComponent(v, c) {
  switch (c.tag | 0) {
    case /* Value */0 :
        return Curry._1(v[/* print */6], c[0]);
    case /* Identity */1 :
        return String(c[0]);
    case /* Composition */2 :
        return printComponent(v, c[0]) + (" ⋅ " + printComponent(v, c[1]));
    case /* Tensor */3 :
        var match = c[0];
        if (match) {
          return "[" + (List.fold_left((function (string, comp) {
                          return string + (" ⊗ " + printComponent(v, comp));
                        }), printComponent(v, match[0]), match[1]) + "]");
        } else {
          return "[]";
        }
    case /* Function */4 :
        return c[0];
    case /* Delay */5 :
        return "ẟ[" + (String(c[0]) + "]");
    case /* Trace */6 :
        return "Tr[" + (String(c[0]) + ("](" + (printComponent(v, c[1]) + ")")));
    case /* Iter */7 :
        return "iter[" + (String(c[0]) + ("](" + (printComponent(v, c[1]) + ")")));
    case /* Input */8 :
        return ":" + String(c[0]);
    case /* Output */9 :
        return String(c[0]) + ":";
    case /* Link */10 :
        return "|" + (String(c[0]) + ("-" + (String(c[1]) + ("|" + printComponent(v, c[2])))));
    
  }
}

function printCircuit(param) {
  return printComponent(param[/* v */0], param[/* c */1]);
}

function identity(v, n) {
  return /* record */[
          /* v */v,
          /* c : Identity */Block.__(1, [n])
        ];
}

function compose(c, c$prime) {
  Helpers$CircuitVisualiser.assert$prime(outputs(c) === inputs(c$prime), "Outputs of circuit " + (printCircuit(c) + (" do not match inputs of circuit " + printCircuit(c$prime))));
  Helpers$CircuitVisualiser.assert$prime(Caml_obj.caml_equal(c[/* v */0], c$prime[/* v */0]), "Circuits use different lattices!");
  return /* record */[
          /* v */c[/* v */0],
          /* c : Composition */Block.__(2, [
              c[/* c */1],
              c$prime[/* c */1]
            ])
        ];
}

function composemany(xs) {
  Helpers$CircuitVisualiser.assert$prime(List.fold_left((function (x, y) {
              if (x) {
                return Caml_obj.caml_equal(y[/* v */0], List.hd(xs)[/* v */0]);
              } else {
                return false;
              }
            }), true, xs), "Not all circuits use the same lattice!");
  if (xs) {
    var xs$1 = xs[1];
    var x = xs[0];
    if (xs$1) {
      return /* record */[
              /* v */List.hd(xs$1)[/* v */0],
              /* c : Composition */Block.__(2, [
                  x[/* c */1],
                  composemany(xs$1)[/* c */1]
                ])
            ];
    } else {
      return x;
    }
  } else {
    return Pervasives.failwith("no args");
  }
}

function tensor(xs) {
  Helpers$CircuitVisualiser.assert$prime(List.fold_left((function (x, y) {
              if (x) {
                return Caml_obj.caml_equal(y[/* v */0], List.hd(xs)[/* v */0]);
              } else {
                return false;
              }
            }), true, xs), "Not all circuits use the same lattice!");
  var ys = List.map((function (x) {
          return x[/* c */1];
        }), xs);
  return /* record */[
          /* v */List.hd(xs)[/* v */0],
          /* c : Tensor */Block.__(3, [ys])
        ];
}

function exp$prime(f, x) {
  if (x === 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            f,
            exp$prime(f, x - 1 | 0)
          ];
  }
}

function exp(f, x) {
  return tensor(exp$prime(f, x));
}

function func(v, id, ins, outs, f) {
  return /* record */[
          /* v */v,
          /* c : Function */Block.__(4, [
              id,
              ins,
              outs,
              f
            ])
        ];
}

function fork(v) {
  return /* record */[
          /* v */v,
          /* c : Function */Block.__(4, [
              "⋏",
              1,
              2,
              (function (param, c) {
                  return /* Tensor */Block.__(3, [/* :: */[
                              c,
                              /* :: */[
                                c,
                                /* [] */0
                              ]
                            ]]);
                })
            ])
        ];
}

function join(v) {
  return /* record */[
          /* v */v,
          /* c : Function */Block.__(4, [
              "⋎",
              2,
              1,
              (function (v, c) {
                  if (c.tag === /* Tensor */3) {
                    var match = c[0];
                    if (match) {
                      var x = match[0];
                      if (!x.tag) {
                        var match$1 = match[1];
                        if (match$1) {
                          var match$2 = match$1[0];
                          if (!match$2.tag) {
                            if (match$1[1]) {
                              return Pervasives.failwith("Join can only take two arguments");
                            } else {
                              return /* Value */Block.__(0, [Curry._2(v[/* joinOp */1], x[0], match$2[0])]);
                            }
                          }
                          
                        } else {
                          return Pervasives.failwith("Join can only take two arguments");
                        }
                      }
                      var match$3 = match[1];
                      if (match$3 && !match$3[1]) {
                        return Pervasives.failwith("Not implemented");
                      } else {
                        return Pervasives.failwith("Join can only take two arguments");
                      }
                    } else {
                      return Pervasives.failwith("Join can only take two arguments");
                    }
                  } else {
                    return Pervasives.failwith("Join can only take two arguments");
                  }
                })
            ])
        ];
}

function swap(v, x, y) {
  return /* record */[
          /* v */v,
          /* c : Function */Block.__(4, [
              "×" + ("[" + (String(x) + ("," + (String(y) + "]")))),
              x + y | 0,
              x + y | 0,
              (function (param, comp) {
                  if (comp.tag === /* Tensor */3) {
                    var match = Helpers$CircuitVisualiser.split(x, comp[0]);
                    return /* Tensor */Block.__(3, [List.concat(/* :: */[
                                    match[1],
                                    /* :: */[
                                      match[0],
                                      /* [] */0
                                    ]
                                  ])]);
                  } else {
                    return Pervasives.failwith("Swap can only swap a tensor");
                  }
                })
            ])
        ];
}

function stub(v) {
  return /* record */[
          /* v */v,
          /* c : Function */Block.__(4, [
              "~",
              1,
              0,
              (function (param, param$1) {
                  return /* Identity */Block.__(1, [0]);
                })
            ])
        ];
}

function dfork(v, n) {
  if (n !== 0) {
    if (n !== 1) {
      return composemany(/* :: */[
                  tensor(/* :: */[
                        dfork(v, n - 1 | 0),
                        /* :: */[
                          fork(v),
                          /* [] */0
                        ]
                      ]),
                  /* :: */[
                    tensor(/* :: */[
                          /* record */[
                            /* v */v,
                            /* c : Identity */Block.__(1, [1])
                          ],
                          /* :: */[
                            swap(v, n - 1 | 0, 1),
                            /* :: */[
                              /* record */[
                                /* v */v,
                                /* c : Identity */Block.__(1, [1])
                              ],
                              /* [] */0
                            ]
                          ]
                        ]),
                    /* [] */0
                  ]
                ]);
    } else {
      return fork(v);
    }
  } else {
    return /* record */[
            /* v */v,
            /* c : Identity */Block.__(1, [0])
          ];
  }
}

function djoin(v, n) {
  if (n !== 0) {
    if (n !== 1) {
      return composemany(/* :: */[
                  tensor(/* :: */[
                        /* record */[
                          /* v */v,
                          /* c : Identity */Block.__(1, [1])
                        ],
                        /* :: */[
                          swap(v, 1, n - 1 | 0),
                          /* :: */[
                            /* record */[
                              /* v */v,
                              /* c : Identity */Block.__(1, [1])
                            ],
                            /* [] */0
                          ]
                        ]
                      ]),
                  /* :: */[
                    tensor(/* :: */[
                          djoin(v, n - 1 | 0),
                          /* :: */[
                            join(v),
                            /* [] */0
                          ]
                        ]),
                    /* [] */0
                  ]
                ]);
    } else {
      return join(v);
    }
  } else {
    return /* record */[
            /* v */v,
            /* c : Identity */Block.__(1, [0])
          ];
  }
}

function delay(n) {
  return /* Delay */Block.__(5, [n]);
}

function trace(x, f) {
  Helpers$CircuitVisualiser.assert$prime(inputs(f) >= x && outputs(f) >= x, "Inputs and outputs of circuit " + (printCircuit(f) + " are less than the size of the trace."));
  return /* record */[
          /* v */f[/* v */0],
          /* c : Trace */Block.__(6, [
              x,
              f[/* c */1]
            ])
        ];
}

function iter(f) {
  Helpers$CircuitVisualiser.assert$prime(inputs(f) >= outputs(f), "Not enough inputs of circuit " + (printCircuit(f) + " to iterate."));
  return /* record */[
          /* v */f[/* v */0],
          /* c : Iter */Block.__(7, [
              outputs(f),
              f[/* c */1]
            ])
        ];
}

function traceAsIteration(trace) {
  var match = trace[/* c */1];
  if (match.tag === /* Trace */6) {
    var x = outputs(trace);
    var f = stub(trace[/* v */0]);
    var n = inputs$prime(match[1]);
    var x$1 = outputs(trace);
    var f$1 = stub(trace[/* v */0]);
    return composemany(/* :: */[
                iter(composemany(/* :: */[
                          tensor(/* :: */[
                                /* record */[
                                  /* v */trace[/* v */0],
                                  /* c : Identity */Block.__(1, [match[0]])
                                ],
                                /* :: */[
                                  tensor(exp$prime(f, x)),
                                  /* :: */[
                                    /* record */[
                                      /* v */trace[/* v */0],
                                      /* c : Identity */Block.__(1, [n])
                                    ],
                                    /* [] */0
                                  ]
                                ]
                              ]),
                          /* :: */[
                            /* record */[
                              /* v */trace[/* v */0],
                              /* c */trace[/* c */1]
                            ],
                            /* [] */0
                          ]
                        ])),
                /* :: */[
                  tensor(/* :: */[
                        tensor(exp$prime(f$1, x$1)),
                        /* [] */0
                      ]),
                  /* [] */0
                ]
              ]);
  } else {
    return Pervasives.failwith("This is not a trace");
  }
}

export {
  inputs$prime ,
  inputs ,
  outputs$prime ,
  outputs ,
  printComponent ,
  printCircuit ,
  identity ,
  compose ,
  composemany ,
  tensor ,
  exp$prime ,
  exp ,
  func ,
  fork ,
  join ,
  swap ,
  stub ,
  dfork ,
  djoin ,
  delay ,
  trace ,
  iter ,
  traceAsIteration ,
  
}
/* No side effect */
