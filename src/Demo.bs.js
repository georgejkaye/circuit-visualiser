// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function printLattice(lattice) {
  switch (lattice) {
    case /* Bottom */0 :
        return "\xe2\x8a\xa5";
    case /* False */1 :
        return "f";
    case /* True */2 :
        return "t";
    case /* Top */3 :
        return "T";
    
  }
}

function inputs(_item) {
  while(true) {
    var item = _item;
    switch (item.tag | 0) {
      case /* Identity */1 :
          return item[0];
      case /* Composition */2 :
          _item = item[0];
          continue ;
      case /* Tensor */3 :
          return List.fold_left((function (no, comp) {
                        return no + inputs(comp) | 0;
                      }), 0, item[0]);
      case /* Gate */4 :
          return item[1];
      case /* Value */0 :
      case /* Input */5 :
          return 0;
      case /* Output */6 :
          return 1;
      case /* Link */7 :
          _item = item[2];
          continue ;
      
    }
  };
}

function outputs(_item) {
  while(true) {
    var item = _item;
    switch (item.tag | 0) {
      case /* Identity */1 :
          return item[0];
      case /* Composition */2 :
          _item = item[1];
          continue ;
      case /* Tensor */3 :
          return List.fold_left((function (no, comp) {
                        return no + outputs(comp) | 0;
                      }), 0, item[0]);
      case /* Gate */4 :
          return item[2];
      case /* Value */0 :
      case /* Input */5 :
          return 1;
      case /* Output */6 :
          return 0;
      case /* Link */7 :
          _item = item[2];
          continue ;
      
    }
  };
}

function compose(f, g) {
  if (outputs(f) !== inputs(g)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Demo.re",
            49,
            4
          ]
        ];
  }
  return /* Composition */Block.__(2, [
            f,
            g
          ]);
}

function composemany(list) {
  if (list) {
    return List.fold_left(compose, list[0], list[1]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Demo.re",
            53,
            32
          ]
        ];
  }
}

function printCircuit$prime(component) {
  switch (component.tag | 0) {
    case /* Value */0 :
        return printLattice(component[0]);
    case /* Identity */1 :
        return String(component[0]);
    case /* Composition */2 :
        return printCircuit$prime(component[0]) + (" ⋅ " + printCircuit$prime(component[1]));
    case /* Tensor */3 :
        var match = component[0];
        if (match) {
          return "[" + (List.fold_left((function (string, comp) {
                          return string + (" ⊗ " + printCircuit$prime(comp));
                        }), printCircuit$prime(match[0]), match[1]) + "]");
        } else {
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Demo.re",
                  59,
                  39
                ]
              ];
        }
    case /* Gate */4 :
        return component[0];
    case /* Input */5 :
        return ":" + String(component[0]);
    case /* Output */6 :
        return String(component[0]) + ":";
    case /* Link */7 :
        return "|" + (String(component[0]) + ("-" + (String(component[1]) + ("|" + printCircuit$prime(component[2])))));
    
  }
}

function printCircuit(circuit) {
  console.log(printCircuit$prime(circuit[2]));
  return /* () */0;
}

var andgate = /* Gate */Block.__(4, [
    "AND",
    2,
    1
  ]);

var orgate = /* Gate */Block.__(4, [
    "OR",
    2,
    1
  ]);

var t = /* Value */Block.__(0, [/* True */2]);

var tensor1 = /* Tensor */Block.__(3, [/* :: */[
      t,
      /* :: */[
        t,
        /* :: */[
          t,
          /* [] */0
        ]
      ]
    ]]);

var tensor2 = /* Tensor */Block.__(3, [/* :: */[
      andgate,
      /* :: */[
        /* Identity */Block.__(1, [1]),
        /* [] */0
      ]
    ]]);

console.log(outputs(tensor1));

console.log(inputs(tensor2));

var circuit = composemany(/* :: */[
      tensor1,
      /* :: */[
        tensor2,
        /* :: */[
          orgate,
          /* [] */0
        ]
      ]
    ]);

console.log("Hello!");

printCircuit(/* Circuit */[
      /* [] */0,
      /* [] */0,
      circuit,
      ""
    ]);

var f = /* Value */Block.__(0, [/* False */1]);

exports.printLattice = printLattice;
exports.inputs = inputs;
exports.outputs = outputs;
exports.compose = compose;
exports.composemany = composemany;
exports.printCircuit$prime = printCircuit$prime;
exports.printCircuit = printCircuit;
exports.andgate = andgate;
exports.orgate = orgate;
exports.t = t;
exports.f = f;
exports.tensor1 = tensor1;
exports.tensor2 = tensor2;
exports.circuit = circuit;
/*  Not a pure module */
