// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function printLattice(lattice) {
  switch (lattice) {
    case /* Bottom */0 :
        return "\xe2\x8a\xa5";
    case /* False */1 :
        return "f";
    case /* True */2 :
        return "t";
    case /* Top */3 :
        return "T";
    
  }
}

function inputs(_item) {
  while(true) {
    var item = _item;
    if (typeof item === "number") {
      return 1;
    } else {
      switch (item.tag | 0) {
        case /* Identity */1 :
            return item[0];
        case /* Composition */2 :
            _item = item[0];
            continue ;
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + inputs(comp) | 0;
                        }), 0, item[0]);
        case /* Gate */4 :
            return item[1];
        case /* Trace */5 :
            return inputs(item[1]) - item[0] | 0;
        case /* Value */0 :
        case /* Input */6 :
            return 0;
        case /* Output */7 :
            return 1;
        case /* Link */8 :
            _item = item[2];
            continue ;
        
      }
    }
  };
}

function outputs(_item) {
  while(true) {
    var item = _item;
    if (typeof item === "number") {
      return 1;
    } else {
      switch (item.tag | 0) {
        case /* Identity */1 :
            return item[0];
        case /* Composition */2 :
            _item = item[1];
            continue ;
        case /* Tensor */3 :
            return List.fold_left((function (no, comp) {
                          return no + outputs(comp) | 0;
                        }), 0, item[0]);
        case /* Gate */4 :
            return item[2];
        case /* Trace */5 :
            return outputs(item[1]) - item[0] | 0;
        case /* Output */7 :
            return 0;
        case /* Link */8 :
            _item = item[2];
            continue ;
        default:
          return 1;
      }
    }
  };
}

function compose(f, g) {
  if (outputs(f) !== inputs(g)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Demo.re",
            55,
            4
          ]
        ];
  }
  return /* Composition */Block.__(2, [
            f,
            g
          ]);
}

function composemany(list) {
  if (list) {
    return List.fold_left(compose, list[0], list[1]);
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Demo.re",
            59,
            32
          ]
        ];
  }
}

function trace(x, comp) {
  if (!(inputs(comp) >= x && outputs(comp) >= x)) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "Demo.re",
            66,
            4
          ]
        ];
  }
  return /* Trace */Block.__(5, [
            x,
            comp
          ]);
}

function printCircuit$prime(component) {
  if (typeof component === "number") {
    return "ẟ";
  } else {
    switch (component.tag | 0) {
      case /* Value */0 :
          return printLattice(component[0]);
      case /* Identity */1 :
          return String(component[0]);
      case /* Composition */2 :
          return printCircuit$prime(component[0]) + (" ⋅ " + printCircuit$prime(component[1]));
      case /* Tensor */3 :
          var match = component[0];
          if (match) {
            return "[" + (List.fold_left((function (string, comp) {
                            return string + (" ⊗ " + printCircuit$prime(comp));
                          }), printCircuit$prime(match[0]), match[1]) + "]");
          } else {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Demo.re",
                    70,
                    39
                  ]
                ];
          }
      case /* Gate */4 :
          return component[0];
      case /* Trace */5 :
          return "Tr[" + (String(component[0]) + ("](" + (printCircuit$prime(component[1]) + ")")));
      case /* Input */6 :
          return ":" + String(component[0]);
      case /* Output */7 :
          return String(component[0]) + ":";
      case /* Link */8 :
          return "|" + (String(component[0]) + ("-" + (String(component[1]) + ("|" + printCircuit$prime(component[2])))));
      
    }
  }
}

function printCircuit(circuit) {
  var comp = circuit[2];
  console.log(circuit[3] + (" : " + (String(inputs(comp)) + (" → " + (String(outputs(comp)) + ("\n" + printCircuit$prime(comp)))))));
  return /* () */0;
}

var andgate = /* Gate */Block.__(4, [
    "AND",
    2,
    1
  ]);

var orgate = /* Gate */Block.__(4, [
    "OR",
    2,
    1
  ]);

var t = /* Value */Block.__(0, [/* True */2]);

var tensor1 = /* Tensor */Block.__(3, [/* :: */[
      t,
      /* :: */[
        t,
        /* :: */[
          t,
          /* [] */0
        ]
      ]
    ]]);

var tensor2 = /* Tensor */Block.__(3, [/* :: */[
      andgate,
      /* :: */[
        /* Identity */Block.__(1, [1]),
        /* [] */0
      ]
    ]]);

console.log(outputs(tensor1));

console.log(inputs(tensor2));

var circuit = composemany(/* :: */[
      tensor1,
      /* :: */[
        tensor2,
        /* :: */[
          orgate,
          /* [] */0
        ]
      ]
    ]);

console.log("Hello!");

printCircuit(/* Circuit */[
      /* [] */0,
      /* [] */0,
      circuit,
      ""
    ]);

var fork = /* Gate */Block.__(4, [
    "⋏",
    1,
    2
  ]);

var f = /* Gate */Block.__(4, [
    "f",
    1,
    1
  ]);

var g = /* Gate */Block.__(4, [
    "g",
    1,
    1
  ]);

var h = /* Gate */Block.__(4, [
    "h",
    2,
    1
  ]);

var tensor3 = /* Tensor */Block.__(3, [/* :: */[
      /* Delay */0,
      /* :: */[
        g,
        /* [] */0
      ]
    ]]);

var tensor4 = /* Tensor */Block.__(3, [/* :: */[
      f,
      /* :: */[
        /* Identity */Block.__(1, [1]),
        /* [] */0
      ]
    ]]);

var circuit2 = composemany(/* :: */[
      fork,
      /* :: */[
        tensor3,
        /* :: */[
          tensor4,
          /* :: */[
            h,
            /* [] */0
          ]
        ]
      ]
    ]);

printCircuit(/* Circuit */[
      /* [] */0,
      /* [] */0,
      circuit2,
      ""
    ]);

var f$prime = /* Gate */Block.__(4, [
    "f",
    3,
    3
  ]);

var circuit3 = trace(2, f$prime);

printCircuit(/* Circuit */[
      /* [] */0,
      /* [] */0,
      circuit3,
      ""
    ]);

var join = /* Gate */Block.__(4, [
    "⋎",
    1,
    2
  ]);

var stub = /* Gate */Block.__(4, [
    "~",
    1,
    0
  ]);

var delay = /* Delay */0;

exports.printLattice = printLattice;
exports.inputs = inputs;
exports.outputs = outputs;
exports.compose = compose;
exports.composemany = composemany;
exports.trace = trace;
exports.printCircuit$prime = printCircuit$prime;
exports.printCircuit = printCircuit;
exports.andgate = andgate;
exports.orgate = orgate;
exports.t = t;
exports.tensor1 = tensor1;
exports.tensor2 = tensor2;
exports.circuit = circuit;
exports.fork = fork;
exports.join = join;
exports.stub = stub;
exports.f = f;
exports.g = g;
exports.h = h;
exports.delay = delay;
exports.tensor3 = tensor3;
exports.tensor4 = tensor4;
exports.circuit2 = circuit2;
exports.f$prime = f$prime;
exports.circuit3 = circuit3;
/*  Not a pure module */
